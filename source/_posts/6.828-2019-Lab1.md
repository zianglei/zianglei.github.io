---
title: 6.828 2019 Lab1
date: 2020-05-01 20:03:00
categories: 笔记
tags:
- 操作系统
toc: true
---

MIT 6.828 2019年的Lab是基于运行在Risc-V上的xv6系统设计的。通过对xv6拓展来学习操作系统的知识。

Lab1主要是熟悉xv6提供的系统调用，并编写user program来实现各种功能。

源代码地址：https://github.com/zianglei/6.828-lab-2019/tree/util

所有代码都在user文件夹下

<!--more-->

## 开胃菜

在sh.c里面有如何实现输入/输出重定向的代码，其原理是在fork之后关闭stdin或者stdout，然后打开重定向目标，这样新打开的目标的file descriptor就会取当前可以用的最小值，取代了原来的stdin或stdout。

同理，在管道的实现中，也是将stdin/stdout关闭，然后使用`dup(pipe[0])`这样的方式将stdin/stdout指向pipe的输入/输出端，从而实现两个命令之间的管道建立。

## sleep

sleep比较简单，直接调用xv6提供的系统调用sleep即可。只是暂时不确定具体是休眠了多少时间（肯定不是以秒为单位）。因为评分系统通过了所以暂时没有深究。

## pingpong

实现两个进程使用pipe互相发送和接收字节的程序。使用了pipe和fork系统调用。也很简单，具体看代码即可。

## primes

利用进程来实现一个流水线机制，打印出[2, 35]范围内的质数。

具体原理可以参考MIT提供的资料网址：https://swtch.com/~rsc/thread/

在这里贴一张图片：

![流水线](http://ziangleiblog.oss-cn-beijing.aliyuncs.com/uPic/20200501210045_sieve.gif)

实现的思路：当一个进程收到上个进程发送过来第一个数字时，将其作为基数和质数打印出来，然后创建一个子进程。之后再收到数字的时候，如果是基数的倍数则不会发送给子进程，不是则发送给子进程。子进程创建时依然执行上述相同的逻辑。

代码片段如下：

```c
  void subprime(int input) {
			int divide, temp;
  		int p[2];

 			if(read(input, &divide, sizeof(int)) <= 0) exit();
  		printf("prime %d\n", divide);
  		
 			if (pipe(p) < 0) {
  				fprintf(2, "pipe\n");
  				exit();
  		}

  		if(fork() == 0) {
  		   	close(p[1]);
  				subprime(p[0]);
  		} else {
  				close(p[0]);
  				while(read(input, &temp, sizeof(int)) >0) {
            	if (temp % divide != 0) {
  				   			write(p[1], &temp, sizeof(int));
  						}
 					}
   				close(p[1]);
  				close(input);
  			  wait();
					exit();
     	}
  }
```

然后在main函数中主进程负责产生数字，创建子进程调用`subprime`函数。

由于在lab1中xv6只支持最多32个file descriptor，而每次fork都会复制两个file descriptor（pipe的两端），因此每次在子进程中都需要将`p[1]`关掉。

## find

实现find主要是学习如果读取文件和文件夹，需要注意的点有：

- 在xv6中一个文件夹实质上也是一个文件，这个文件包含了很多`dirent`结构体，该结构体包含一个inum编号和文件名
- 使用fstat判断是文件还是文件夹
- 递归find的时候需要跳过`.`和`..`两个特殊路径

核心代码如下：

```c
void find(char* path, char* name) {
	int fd;
	struct stat st;
	struct dirent de;
	char buf[512], *p;

	if ((fd = open(path, 0)) < 0) {
		fprintf(2, "find: cannot open %s\n", path);
		return;
	}

	if (fstat(fd, &st) < 0) {
	    fprintf(2, "find: cannot stat %s\n", path);
	    close(fd);
	    return;
	}

    switch (st.type) {
	    case T_FILE:
	        if (strcmp(fmtname(path), name) == 0) {
	            printf("%s\n", path);
	        }
	        break;
	    case T_DIR:
	        if (strlen(path) + 1 + DIRSIZ + 1 > sizeof(buf)) {
	            fprintf(2, "find: path too long\n");
	            break;
	        }
	        strcpy(buf, path);
	        p = buf + strlen(buf);
	        *p++ = '/';
	        while (read(fd, &de, sizeof(de)) == sizeof(de)) {
	            if (de.inum == 0) continue;
	            if (strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0) continue;
	            memmove(p, de.name, DIRSIZ);
                p[DIRSIZ] = 0;
                find(buf, name);
	        }
	        break;
    }
	close(fd);
}
```

## xargs

xargs 的作用是将从标准输入中获取参数并作为xargs自身参数中指定的命令的参数

需要注意的点：

- 如果在终端中输入ctrl-d，那么从stdin中就会读到EOF，如果调用read函数就会返回0
- 代码实现中只有malloc，没有free，是因为没有找到xv6提供的free函数，待确认。

核心代码如下：

```c
int main(int argc, char* argv[]) {

    if (argc < 2) {
        fprintf(2, "no command specified!\n");
        exit();
    }
    // read arguments from stdin
    char argbuf[ARG_MAX_LENGTH];
    // arguments for subcommand.
    char *subargv[MAXARG];
    int subargc = 0;
    // read subargv from argv to get subcommand and arguments
    for (; subargc + 1 < argc; subargc++) {
        subargv[subargc] = argv[subargc + 1];
    }

    int subargc_start = subargc;
    int runcmd = 0, argbuf_index = 0;
    while (read(0, argbuf + argbuf_index, sizeof(char)) == sizeof(char)) {
        if (argbuf[argbuf_index] == '\n' || argbuf[argbuf_index] == ' ') {
            runcmd = (argbuf[argbuf_index] == '\n') ? 1 : 0;
            argbuf[argbuf_index] = 0;
            subargv[subargc] = malloc(ARG_MAX_LENGTH);
            memmove(subargv[subargc], argbuf, argbuf_index);
            subargc++;
            argbuf_index = 0;
        } else {
            if (argbuf_index == ARG_MAX_LENGTH) continue;
            argbuf_index++;
        }

        if (runcmd) {
            if (fork() == 0) {
                exec(subargv[0], subargv);
            } else {
                wait();
                runcmd = 0;
                argbuf_index = 0;
                subargc = subargc_start;
            }
        }
    }
    exit();
}
```

