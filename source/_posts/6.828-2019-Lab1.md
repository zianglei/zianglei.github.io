---
title: 6.828 2019 Lab1
date: 2020-05-01 20:03:00
categories: 操作系统
toc: true
---

MIT 6.828 2019年的Lab是基于运行在Risc-V上的xv6系统设计的。通过对xv6拓展来学习操作系统的知识。

Lab1主要是熟悉xv6提供的系统调用，并编写user program来实现各种功能。

源代码地址：https://github.com/zianglei/6.828-lab-2019/tree/util

所有代码都在user文件夹下

<!--more-->

## sleep

sleep比较简单，直接调用xv6提供的系统调用sleep即可。只是暂时不确定具体是休眠了多少时间（肯定不是以秒为单位）。因为评分系统通过了所以暂时没有深究。

## pingpong

实现两个进程使用pipe互相发送和接收字节的程序。使用了pipe和fork系统调用。也很简单，具体看代码即可。

## primes

利用进程来实现一个流水线机制，打印出[2, 35]范围内的质数。

具体原理可以参考MIT提供的资料网址：https://swtch.com/~rsc/thread/

在这里贴一张图片：

![流水线](http://ziangleiblog.oss-cn-beijing.aliyuncs.com/uPic/20200501210045_sieve.gif)

实现的思路：当一个进程收到上个进程发送过来第一个数字时，将其作为基数和质数打印出来，然后创建一个子进程。之后再收到数字的时候，如果是基数的倍数则不会发送给子进程，不是则发送给子进程。子进程创建时依然执行上述相同的逻辑。

代码片段如下：

```c
  void subprime(int input) {
			int divide, temp;
  		int p[2];

 			if(read(input, &divide, sizeof(int)) <= 0) exit();
  		printf("prime %d\n", divide);
  		
 			if (pipe(p) < 0) {
  				fprintf(2, "pipe\n");
  				exit();
  		}

  		if(fork() == 0) {
  		   	close(p[1]);
  				subprime(p[0]);
  		} else {
  				close(p[0]);
  				while(read(input, &temp, sizeof(int)) >0) {
            	if (temp % divide != 0) {
  				   			write(p[1], &temp, sizeof(int));
  						}
 					}
   				close(p[1]);
  				close(input);
  			  wait();
					exit();
     	}
  }
```

然后在main函数中主进程负责产生数字，创建子进程调用`subprime`函数。

