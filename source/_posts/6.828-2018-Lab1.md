---
title: 6.828 2018 Lab 1
date: 2020-04-27 10:00:03
categories: 笔记
tags:
- 操作系统
toc: true
---
MIT 6.828 2018 Lab 1 记录

## 相关资料

指令后缀的含义表格：http://ref.x86asm.net/

指令快速索引：https://www.felixcloutier.com/x86/index.html

<!--more-->

Lab1主要是搭建QEMU仿真环境和熟悉x86汇编

由于实验所需环境是32位的，而我们通常的系统都是64位的，因此需要安装gcc-multilib

<img src="http://ziangleiblog.oss-cn-beijing.aliyuncs.com/uPic/20200427190839_image-20200424211156329.png" alt="内存结构" style="zoom:50%;" />

早期的8088的PC只能寻址1MB物理内存（因为只有 20-bit 地址线），而之后的80386可以支持最多4G内存，但是现在的内存架构为了兼容性仍然保留了0x000A000-0x0010000部分。

## 实验记录

### Part1: BIOS

当处理器复位后，处理器会进入`real mode`，复位的寻址地址默认为 0x000ffff0。此时的寻址模式为`Addr = CS << 4 + IP`

软盘或者硬盘会被分为512字节的`sectors`，第一个sector被称为boot sector。在QEMU中自带BIOS。如果BIOS发现了可启动设备，就会从第一个sector里面读出boot loader到内存中的某个特定地址（在8086中为0x7c00-0x7dff）。

### Part2: Boot Loader

在BootLoader中，会将处理器从`real mode`切换为`32-bit protected mode`（80386）。`real mode`与`32-bit protected mode`的区别为

>- 寄存器扩展（由16位扩展到了32位）
>- 段寄存器变化为32位，寻址模式变成了段寄存器+IP寄存器

从`real mode`切换到`32-bit protected mode`的步骤（参考 *[Intel 80386 Programmer's Reference Manual](http://www.logix.cz/michal/doc/i386/)* 10.3.1节）

>- 设置GDT寄存器指向有效的GDT表（使用lgdt命令）
>- 设置CR0寄存器的PE位为1，启动保护模式
>- 使用LJMP命令跳转到下一条指令，实则是为了清空处理器中的预先获取的指令队列

#### 跳转指令

在boot.S中，使用LJMP跳转到下一条指令为

```assembly
ljmp    $PROT_MODE_CSEG, $protcseg # PROT_MODE_CSEG=0x80
```

ljmp指令会将PROT_MODE_CSEG存储在CS寄存器，protcseg存储在EIP寄存器。

因为PROT_MODE_CSEG=0x80，即选中了GDT表中的code段，基地址仍为0x0000，所以跳转后的地址为protcseg所在的地址。



然后会设置运行环境，跳转到bootmain进入C程序，加载内核。

Lab1中关于bootloader的问题

>What is the *last* instruction of the boot loader executed, and what is the *first* instruction of the kernel it just loaded?

bootloader最后执行的指令是`call *0x10018`，跳转到kernel的入口地址0x10000C；kernel的第一条指令为`movw   $0x1234,0x472`

> Where is the first instruction of the kernel?

第一条指令位于0x1000C处

> How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?

从bootmain函数中的逻辑可知，其首先读取硬盘的第一页（8*512字节），获得ELF的头部信息，然后解析出头部信息中存储的程序段起始位置和程序段数量以及各程序段的偏移值（这些数据可以通过objdump读取ELF文件获得），依此读取程序段，最后跳转到入口函数位置。

bootmain代码

```c
void
bootmain(void)
{
        struct Proghdr *ph, *eph;

        // read 1st page off disk
        readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);

        // is this a valid ELF?
        if (ELFHDR->e_magic != ELF_MAGIC)
                goto bad;

        // load each program segment (ignores ph flags)
        ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
        eph = ph + ELFHDR->e_phnum;
        for (; ph < eph; ph++)
                // p_pa is the load address of this segment (as well
                // as the physical address)
                readseg(ph->p_pa, ph->p_memsz, ph->p_offset);

        // call the entry point from the ELF header
        // note: does not return!
        ((void (*)(void)) (ELFHDR->e_entry))();

bad:
        outw(0x8A00, 0x8A00);
        outw(0x8A00, 0x8E00);
        while (1)
                /* do nothing */;
}

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint32_t pa, uint32_t count, uint32_t offset)
{
        uint32_t end_pa;

        end_pa = pa + count;

        // round down to sector boundary
        pa &= ~(SECTSIZE - 1);

        // translate from bytes to sectors, and kernel starts at sector 1
        offset = (offset / SECTSIZE) + 1;	

        // If this is too slow, we could read lots of sectors at a time.
        // We'd write more to memory than asked, but it doesn't matter --
        // we load in increasing order.
        while (pa < end_pa) {
                // Since we haven't enabled paging yet and we're using
                // an identity segment mapping (see boot.S), we can
                // use physical addresses directly.  This won't be the
                // case once JOS enables the MMU.
                readsect((uint8_t*) pa, offset);
                pa += SECTSIZE;
                offset++;
        }
}
```

#### ELF

ELF格式是编译器进行编译链接之后的执行文件格式，我们主要关注这种格式的头部，头部包含ELF头部和变长的程序段头部。BootLoader需要做的就是将这些程序段头部拷贝到相应的位置。

在程序段头部中，主要关注以下几个部分

- .text：汇编代码段
- .rodata：常量数据
- .bss：未初始化的全局数据
- .data：初始化过的全局数据

可以使用objdump输出ELF文件的各部分的信息

VMA表示link address，LMA表示load address。LMA表示代码段被加载到内存中的地址，VMA表示代码段应该被执行的位置。

### Part3: Kernel

根据kernel的头部信息，可以得知kernel会在`0xf0100000`处执行代码，但是很多电脑并没有那么大的内存空间，所以需要使用虚拟地址进行映射。在LAB中是将`0xf0000000-0xffffffff`映射到`0x00000000-0x0fffffff`

> Exercise 7：What is the first instruction *after* the new mapping is established that would fail to work properly if the mapping weren't in place? Comment out the `movl %eax, %cr0` in `kern/entry.S`, trace into it, and see if you were right.

在映射建立之后，会跳转到relocated代码区域执行代码。如果关闭映射，跳转并不会受到影响，受到影响的是跳转之后执行的代码。

回答问题：

> Explain the interface between `printf.c` and `console.c`. Specifically, what function does `console.c` export? How is this function used by `printf.c`?

console.c 提供`cputchar`,`getchar`和`iscons`函数，printf.c使用cputchar输出字符

>Explain the following from `console.c`:

```c
if (crt_pos >= CRT_SIZE) {
  int i;
  memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
    crt_buf[i] = 0x0700 | ' ';
  crt_pos -= CRT_COLS;
}
```

这段代码是用来进行滚屏，将显示的内容上移一行，并将最下面一行清空作为新行。其中0x0700代表VGA中的字符颜色，设置字符颜色为`Light Gray`

关于VGA Text Mode的参考：https://os.phil-opp.com/vga-text-mode/（需梯子）

#### Stack

在x86中`EBP`寄存器存储相对当前函数的栈基地址，`ESP`寄存器存储栈顶地址

```
		       +------------+   |
		       | arg 2      |   \
		       +------------+    >- previous function's stack frame
		       | arg 1      |   /
		       +------------+   |
		       | ret %eip   |   /
		       +============+   
		       | saved %ebp |   \
		%ebp-> +------------+   |
		       |            |   |
		       |   local    |   \
		       | variables, |    >- current function's stack frame
		       |    etc.    |   /
		       |            |   |
		       |            |   |
		%esp-> +------------+   /
```

调用函数示例

```assembly
_main:
					# prologue
			pushl %ebp
			movl %esp, %ebp
					# body
			pushl $8
			call _f
			addl $1, %eax
					# epilogue
			movl %ebp, %esp
			popl %ebp
			ret
		_f:
					# prologue
			pushl %ebp
			movl %esp, %ebp
					# body
			pushl 8(%esp)
			call _g
					# epilogue
			movl %ebp, %esp
			popl %ebp
			ret

		_g:
					# prologue
			pushl %ebp
			movl %esp, %ebp
					# save %ebx
			pushl %ebx
					# body
			movl 8(%ebp), %ebx
			addl $3, %ebx
			movl %ebx, %eax
					# restore %ebx
			popl %ebx
					# epilogue
			movl %ebp, %esp
			popl %ebp
			ret
```

调用约定

- %eax, %ecx, %edx are "caller save" registers
- %ebp, %ebx, %esi, %edi are "callee save" registers

到调用call指令的时候，会在堆栈中存入call指令的下一条指令地址。

在堆栈中，函数的参数从后往前入栈，也就是说函数的第一个参数在栈顶

> 问题3：
>
> - In the call to cprintf(), to what does fmt point? To what does ap point?
> - List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments.

fmt指向的是格式字符串的首地址，ap指的是堆栈中第一个参数的首地址，在此就是参数1在堆栈中的地址

调用的协议栈如下

```
              +------------+
              |            |
              +------------+ <---+ 0xf010fff8
              |   ......   |
              +------------+
              |     4      |
              +------------+
              |     3      |
              +------------+
              |     1      |
              +------------+ <---+ 0xf010ffd4
              | 0xf0101a37 | <---+ fmt
              +------------+
              | 0xf01000e6 | <---+ next instruction
         +--> +------------+       address after call
         |    | 0xf010fff8 | <---+ the previous ebp
         |    +------------+ <---+ 0xf010ffc8 ebp in cprintf
         |    |            |
 cprintf |    +------------+
         |    |            |
         |    +------------+
         |    |            |
         |    +------------+
         |    |            |
         |    +------------+
         |    | 0xf010ffd4 | ap = 0
         |    +------------+
         |    | 0xf0101a37 | fmt
         |    +------------+
         |    | 0xf0100a6d |
         +--> +------------+
         |    | 0xf010ffc8 |
         |    +------------+ <---+ 0xf010ffa8
         |    | 0xf0111308 |
         |    +------------+
         |    |            |
vcprintf |    +------------+
         |    |      0     | <---+ cnt = 0
         |    +------------+ <---+ 0xf010ff9c
         |    |            |
         |    +------------+
         |    |            |
         |    +------------+
         |    |            |
         |    +------------+
         |    | 0xf010ffd4 | ap
         |    +------------+
         |    | 0xf0101a37 | fmt
         |    +------------+
         |    | 0xf010ff9c | &cnt
         |    +------------+
         |    | 0xf0100a02 | putch
         |    +------------+
         |    | 0xf0100a53 |
         +--> +------------+
              |   ......   |
              +------------+
```

> Run the following code.
>
> ```c
> unsigned int i = 0x00646c72;
> cprintf("H%x Wo%s", 57616, &i);
> ```
>
> What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. [Here's an ASCII table](http://web.cs.mun.ca/~michael/c/ascii-table.html) that maps bytes to characters.

57616的十进制为e110，则输出为He110，i在内存中的字节顺序为`0x72 0x6c 0x64 0x00` 转换成字符为`r l d \0 `

如果改成大端模式的话，i要改为0x726c6400，而57616不需要更改，因为在cprintf内部是将57616转换为十六进制再显示，与在内存中存放的字节顺序无关。

>In the following code, what is going to be printed after `'y='`? (note: the answer is not a specific value.) Why does this happen?
>
>```c
>cprintf("x=%d y=%d", 3);
>```

在我的电脑上会输出`x=3, y=1600`，原因是因为ap刚开始指向的是3所在的栈的位置，在解析格式字符串后，ap会向上递增，从而会将3之后的栈中的内容作为整数输出。

> Let's say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change `cprintf` or its interface so that it would still be possible to pass it a variable number of arguments?

如果按照声明顺序将参数入栈，则一种可行的方法是在声明的时候将可变参数与格式字符串交换位置，并在传入可变参数的时候按照从后往前的顺序传入；或者在参数中加入参数的数量，从而根据参数的数量指定ap指向的地址。

#### 添加%o选项

向`printf`添加`%o`选项，经过上面的“洗礼”，很容易就知道在`vprintfmt`函数的switch中加一个分支：

```c
// (unsigned) octal
case 'o':	
    // Replace this with your code.
    num = getuint(&ap, lflag);
    base = 8;
    goto number;
```

#### Challenge Enhance

TODO

### Part4: Stack

>**Exercise 9.** Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which "end" of this reserved area is the stack pointer initialized to point to?

内核代码在entry.S的`0xf0100034`指令处初始化了`ESP`寄存器，设置栈顶地址，栈的空间为`KSTKSIZE=PGSIZE * 8`。内核在entry.S里通过`.space`声明栈空间。由于栈的PUSH操作是将ESP减去某个值，所以栈指针初始的时候指的是栈底。

>**Exercise 10.** To become familiar with the C calling conventions on the x86, find the address of the `test_backtrace` function in `obj/kern/kernel.asm`, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of `test_backtrace` push on the stack, and what are those words?
>
>Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the [tools](https://pdos.csail.mit.edu/6.828/2018/tools.html) page or on Athena. Otherwise, you'll have to manually translate all breakpoint and memory addresses to linear addresses.

主要是熟悉x86中的calling convensitions，如Part3中绘制的栈结构一样，当使用call调用一个函数的时候，栈内容如下：

```
         +---+  +----------------+
         |      |     arg[4]     |
         |      +----------------+
         |      |     arg[3]     |
         |      +----------------+
         |      |     arg[2]     |
         |      +----------------+
         |      |     arg[1]     |
         |      +----------------+
         +      |     arg[0]     |
callee function +----------------+
         +      |      EIP       |
         |      +----------------+
         |      |   caller ebp   |
         |      +----------------+ <----+ callee ebp
         |      |                |
         |      |                |
         |      |    ......      |
         |      |                |
         |      |                |
         +----+ +----------------+
```



#### Exercise 11

>**Exercise 11.** Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn't. *After* you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.
>
>If you use `read_ebp()`, note that GCC may generate "optimized" code that calls `read_ebp()` *before* `mon_backtrace()`'s function prologue, which results in an incomplete stack trace (the stack frame of the most recent function call is missing). While we have tried to disable optimizations that cause this reordering, you may want to examine the assembly of `mon_backtrace()` and make sure the call to `read_ebp()` is happening after the function prologue.

根据Exercise 10的知识，可以通过递归寻找EBP的方式获取整个调用栈。由于EBP初始为0，所以循环到EBP为0的时候就可以结束。

```c
int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
        // Your code here.
        uint32_t ebp, eip, *args;
        ebp = read_ebp();
        cprintf("Stack backtrace:\n");
        while (ebp) {
                args = (uint32_t*)(ebp + 0x08);
                cprintf("ebp %8x  eip %08x  args %08x %08x %08x %08x %08x\n",
                        ebp, *((uint32_t*)(ebp + 0x04)), args[0], args[1], args[2], args[3], args[4]);
                ebp = *((uint32_t*)ebp);
        }
        return 0;
}
```

#### Exercise 12

练习12是通过查找gdb产生的stabs来获取代码文件信息，根据`debuginfo_eip`中已有的信息，可以得知需要调用`stab_binsearch`，传入`&lline`、`&rline`和`addr`。

根据头文件的提示，stab类型应该选取N_SLINE。

⚠️通过二分查找获得的lline和rline是汇编代码中函数所在的位置，根据[文档](https://sourceware.org/gdb/onlinedocs/stabs.html#Line-Numbers)描述，stab的n_desc字段才存储着源文件的行数。

```c
stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
if (lline <= rline) {
  info->eip_line = stabs[lline].n_desc;
} else {
  return -1;
}
```