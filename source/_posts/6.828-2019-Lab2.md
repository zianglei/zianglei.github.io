---
title: 6.828 2019 Lab2
date: 2020-05-29 14:22:00
categories: 笔记
tags:
- 操作系统
toc: true
---

代码地址：https://github.com/zianglei/6.828-lab-2019/tree/sh

## 思路

按照实验的知道，参考了`sh.c`的实现。主要是借鉴了`sh.c`里的`gettoken`函数和`peek`函数。

`gettoken`函数是用来解析一行命令中的关键字符串，返回解析到的字符串的类型，并将`input`指针指向下一个关键字符串的位置。`peek`函数用来判断`input`指针指向的字符是否是期待的字符。

由于测试代码只测试了两个命令通过管道连接，因此并没有实现多个管道相互连接的情况。

解析命令首先从第一个字符开始，首先通过`gettoken`函数获得第一个要执行的命令以及对应的参数，直到`gettoken`返回0（表示该行命令解析结束）或者下一个字符是管道字符。每解析一个命令/参数字符串，都要判断一下是否下一个是重定向字符（">"/"<"），如果是，则解析重定向的文件名。

当解析命令函数退出后，会出现两种情况，一种是下一个字符是管道字符，另一种是该行命令已经结束。因此通过`peek`函数判断是否是管道字符，如果是就继续解析下一个命令。

由于实验要求不能用malloc动态分配内存。因此程序中使用数组来保存命令。当所有命令解析完成✅之后，开始执行命令。

每个命令执行之前都需要判断是否需要重定向，如果需要，则将stdin/stdout关闭，然后打开对应的重定向文件。

由于测试代码最多只包含两个命令。因此先判断是否数组中只有一个命令。如果是，则先创建一个进程，然后只需要判断是否需要重定向即可。如果是两个命令，则主进程创建管道，并且创建两个进程。每个进程首先判断是否需要重定向，如果不需要重定向，则将对应的管道绑定到stdin/stdout，最后执行命令。

注意在判断重定向的时候，会同时存在重定向输入和重定向输出的情况。

## 诡异的bug

在将一些被调用的函数放到其他调用它的函数的上方时，会因为jalr指令跳转出错导致内存地址错误，暂时还不知道什么原因。

## 调试方法

由于`sh.c`使用`exec`来进行子线程的内存替换，因此无法直接使用gdb直接进行调试用户程序。一个取巧的方法是获得用户程序汇编代码中某个函数的地址，然后在gdb中在对应地址直接打断点，这样就可以在执行`exec`后直接在函数位置进行中断。



