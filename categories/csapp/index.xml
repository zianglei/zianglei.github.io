<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cs:app on Justin Lei</title><link>https://lza852.com/categories/csapp/</link><description>Recent content in cs:app on Justin Lei</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© Justin Lei</copyright><lastBuildDate>Mon, 23 Aug 2021 08:35:00 +0800</lastBuildDate><atom:link href="https://lza852.com/categories/csapp/index.xml" rel="self" type="application/rss+xml"/><item><title>cs:app attacklab 记录</title><link>https://lza852.com/posts/2021-08-23-csapp-3/</link><pubDate>Mon, 23 Aug 2021 08:35:00 +0800</pubDate><guid>https://lza852.com/posts/2021-08-23-csapp-3/</guid><description>这一部分在cs:app书籍中只有两小节，却单独有一个lab
常见的攻击方式 缓存区溢出 由于C不对数组边界进行检查，当在栈上为数组分配空间时，如果写入的数据超过了数组空间，就会覆盖栈中存储的状态信息。通常使用字符串缓存区溢出来实现。
char *gets(char* s) { int c; char *dest = s; // 没有对边界进行检查 while ((c = getchar()) != &amp;#39;\n&amp;#39; &amp;amp;&amp;amp; c != EOF) *dest++ = c; if (c == EOF &amp;amp;&amp;amp; dest == s) return NULL; *dest++ = &amp;#39;\0&amp;#39;; return s; } 生成的汇编代码如下
echo: subq $24, %rsp movq %rsp, %rdi call gets movq %rsp, %rdi call puts addq $24, %rsp ret 根据汇编代码可以看出，函数分配了24字节的栈空间，因此如果写入的字符串超过了24个字符，那么栈中的返回地址就会被覆盖；如果超过了32字节（24+8），那么调用者中保存的状态也会被覆盖。（栈中保存的数据格式参考这里）
攻击形式 可以在溢出的字符串中包含指向特定可执行代码的指针，用来覆盖返回地址，那么就可以在函数结束后跳转到指定的函数执行。
对抗方法 栈随机化</description></item></channel></rss>