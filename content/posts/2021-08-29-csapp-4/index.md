---
title: "cs:app 第四章 & architecture lab 记录"
date: 2021-08-29T09:45:03+08:00
draft: true
toc: true
Description: 魔改版x86-64架构，学习cpu的架构
---

## Y86-64 的改动

- movq 分成了四个不同的指令：irmovq，rrmovq，mrmovq 和 rmmovq，显式指定了移动的源和目的。i（立即数）、r（寄存器）、m（内存）
- <strong>整数操作指令只能操作寄存器，而不能直接对内存进行操作</strong>。因此需要使用mov 指令将内存数据移动到寄存器，然后再进行整数操作
- 需要使用 halt 停止指令的执行
- 条件码包括 ZF、SF、OF
- 状态寄存器包括
  - AOK：正常操作
  - HLT：遇到执行HLT操作
  - ADR：非法地址
  - INS：非法指令

## pushq 和 popq 的实现细节

pushq %rsp 会首先将 %rsp 的值放入栈中，然后将 %rsp 减 8

popq %rsp 会首先将 %rsp + 8，然后将指向的值放入寄存器

## 完整代码结构

一个完整的汇编代码需要先使用汇编器伪指令告诉汇编器数据和代码的具体位置，然后设置栈的位置

```assembly
	.pos 0 # 表示在内存中的相对位置
	irmovq stack, %rsp  	# 设置栈的位置
	call main # 调用 main 函数
	halt			# 终止程序执行

# 按照 8 字节对齐，即每个元素的地址都能被 8 整除
	.align 8
array:	
	.quad 0x000d000d000d
	.quad 0x00c000c000c0
	.quad 0x0b000b000b00
	.quad 0xa000a000a000

main:	
	irmovq array,%rdi
	irmovq $4,%rsi
	call sum		# sum(array, 4)
	ret

sum:	
	irmovq $8,%r8        # Constant 8
	irmovq $1,%r9	     # Constant 1
	xorq %rax,%rax	     # sum = 0
	andq %rsi,%rsi	     # Set CC
	jmp     test         # Goto test
loop:	mrmovq (%rdi),%r10   # Get *start
	addq %r10,%rax       # Add to sum
	addq %r8,%rdi        # start++
	subq %r9,%rsi        # count--.  Set CC
test:	jne    loop          # Stop when 0
	ret                  # Return

# 栈地址从此处开始，向更低的地址增长
	.pos 0x200
stack:

```

## 处理器结构

处理器处理一条指令一般分为5个阶段：取指、译码、执行、访存、写回五个阶段。

指令集设计的一条原则是：<strong>从不回读</strong>。即处理器不会为了完成一条指令的执行而去读取由该指令更新了的状态。

流水线能够加速指令执行，按照不同阶段划分不同的组合逻辑，逻辑之间使用寄存器保存中间状态，从而实现了充分利用硬件单元，缩短时钟周期。

### 影响流水线的因素

1. 不一致的划分

   如果各级流水线阶段所产生的延迟不一致，那么最终时钟运行频率将由最慢的延迟决定。因此要尽量保证各个阶段的流水线耗时平衡

2. 流水线过深

   当流水线过深之后，组合逻辑之间的寄存器就成为了延时的主要因素，这样时钟周期缩短但是吞吐量（GIPS）却提升不高

### 流水线产生的冒险（hazard）

#### 数据冒险

数据冒险是指一条指令的操作数被它前面三条指令（在五级流水线条件下）任意一条改变的话，就会出现数据冒险，是因为流水线是在译码阶段从寄存器文件中取出操作数，要经过三个周期，在写回阶段将指令结果写到寄存器文件。

解决方法：

1. 使用暂停（stalling）避免数据冒险

   在程序执行的时候插入空指令，这个指令不会影响各级寄存器的状态，从而让指令延后一个周期执行。暂停比较容易实现，但是会严重降低处理器的吞吐率。

2. 使用转发避免数据冒险

   ALU计算时，会根据指令冲突情况，选择不同的源作为A、B计算值，在五级流水中一共有五个转发源，分别是：

   - 执行阶段ALU计算结果
   - 访存阶段ALU计算结果
   - 访存阶段内存读取数据
   - 写回阶段内存读取数据
   - 写回阶段ALU计算结果

   转发不能解决“加载/使用”数据冒险（load/use hazard），因为在访存阶段数据才会从内存中读出来，但是下一条指令在译码阶段就会使用数据，无法将数据通过转发送给过去的时间！因此我们需要在这两条指令之间加入暂停操作，等待一个周期之后再使用转发。这种操作叫做加载互锁（load interlock）。

#### 控制冒险

当我们无法根据取指阶段当前指令来确定下一条指令的地址时，就会出现控制冒险，一般出现在跳转指令和 ret 指令。我们可以使用指令预测来预测跳转指令的执行，如果预测失败，就向流水线中插入气泡，取消之前执行的目标指令即可。

### 流水线对异常的处理

当一条指令出现异常时，指令应该被取消，处理器向上报告异常。在加入流水线之后，会产生几个细节问题：

1. 流水线会读取多个指令，当多个指令发生异常时，我们应该向操作系统报告流水线深度最深的指令
2. 当取出一条指令开始执行，出现异常，但是之后由于分支预测错误，该指令又被取消执行，因此该异常就不应该被上报
3. 由于流水线处理器会在不同阶段更新不同的状态寄存器，因此当一条指令导致异常，后面的指令在异常指令完成之前改变了部分状态，这是不能发生的。

解决方法是，在每个流水线寄存器中都加入状态码，当一条指令在某个阶段处于异常状态，该状态码就会被设置成相关异常状态值，并随着流水线寄存器一起流动，直到写回阶段发现异常，并停止执行。

为了避免出现第三种情况，在访存阶段和写回阶段中的指令导致异常时，流水线控制逻辑就必须禁止更新条件码寄存器和数据内存。

### 评估流水线的性能

我们通过确定往流水线中插入气泡的频率，来衡量流水线效率的损失，通过量化 CPI （每指令周期数），来判断处理器执行效率。

在忽略异常带来的性能损失之后，我们会有三种特殊情况插入气泡，如果这个阶段一共处理了 $C_i$ 个指令和 $ C_b$ 个气泡，那么我们需要使用 $ C_i + C_b $ 个时钟周期来处理 $ C_i $ 个指令，因此效率就是 $ CPI = 1 + \frac{C_i}{C_b} $。因为只有三种指令类型，我们可以将处罚项分为三个部分

$ CPI = 1.0 + lp + mp + rp $，lp 代表加载/使用冒险的平均数，mp 代表预测错误，rp 代表返回处罚，每种处罚都是由该原因产生的气泡总数除以执行指令的总数。

这三种指令在代码中的出现频率为（此处有引用）：

- lp: 加载指令占所有指令的 0.25，其中 0.2 会导致加载/使用冒险，产生 1 个气泡
- mp：条件分支占所有指令的 0.2，其中 0.6 会选择分支，0.4 不会选择分支，产生 2 个气泡
- rp：返回指令占所有指令的 0.02，产生 3 个气泡

如果想要进一步降低 CPI，需要加强预测错误的能力。在此处我们选择的是总是预测条件指令会发生跳转，出错概率为 40%。

### 更多的工作

- 多周期指令：例如乘法和除法指令需要多个周期执行，那么我们可以简单的在执行阶段加入浮点运算单元，并暂停其他单元的执行。

  另一种方法是采用独立于主流水线的特殊硬件功能单元来处理，在译码阶段将指令发射到特殊单元，因此不同单元的操作必须同步，因此需要处理更多的冒险，在存在数据相关的地方暂停系统某个部分的执行。

- 与存储系统的接口，添加 TLB 和 Cache 等缓存。
- 超标量设计：在上面分析性能的时候，CPI 最小为 1.0，即每个周期发射一条指令。但是在超标量设计中，可以并行地取指、译码和执行多条指令，实现小于 1.0 的 CPI

## Architecture Lab

### Part A

> 写三个汇编代码，分别实现 sum, rsum 和 copy 功能

```c
typedef struct ELE {
    long val;
    struct ELE *next;
} *list_ptr;

/* sum_list - Sum the elements of a linked list */
long sum_list(list_ptr ls)
{
    long val = 0;
    while (ls) {
			val += ls->val;
			ls = ls->next;
    }
    return val;
}

/* rsum_list - Recursive version of sum_list */
long rsum_list(list_ptr ls)
{
    if (!ls)
			return 0;
    else {
			long val = ls->val;
			long rest = rsum_list(ls->next);
			return val + rest;
    }
}

/* copy_block - Copy src to dest and return xor checksum of src */
long copy_block(long *src, long *dest, long len)
{
    long result = 0;
    while (len > 0) {
			long val = *src++;
			*dest++ = val;
			result ^= val;
			len--;
    }
    return result;
}
/* $end examples */

```

只要熟悉常见的循环和分支的汇编写法，并注意 y86-64 中整数操作指令只能操作寄存器即可。

注意在 rsum 中，需要使用栈来保存每次递归函数的参数值和返回值，以及相关的中间变量（按照 calling convention）

### Part B

Part B 因为需要图形界面调试，因此暂时不做



